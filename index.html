<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>מחשבון מפורט - הידראוליקה</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --primary: #0288D1;
            --accent: #E65100;
            --text: #222;
            --panel: #ffffff;
            --bg: #f4f7f6;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0; padding: 0; background: var(--bg); color: var(--text);
            height: 100vh; display: flex; flex-direction: column; overflow: hidden;
            text-align: right;
        }

        /* Canvas */
        #canvas-container {
            position: relative; width: 100%; height: 40vh;
            background: #eef4f9; border-bottom: 2px solid #ddd;
            overflow: hidden; touch-action: none;
        }
        canvas { display: block; width: 100%; height: 100%; }
        .overlay-hint {
            position: absolute; top: 10px; right: 10px;
            background: rgba(255,255,255,0.8); padding: 5px 10px;
            border-radius: 15px; font-size: 0.7rem; color: #666; pointer-events: none;
        }

        /* Controls */
        .control-strip {
            background: var(--panel); padding: 15px 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05); z-index: 10; flex-shrink: 0;
        }
        .slider-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 8px; color: var(--primary); font-weight: 700;
        }
        input[type=range] { width: 100%; height: 25px; accent-color: var(--primary); }

        /* Scroll Content */
        .scroll-content {
            flex: 1; overflow-y: auto; padding: 15px; padding-bottom: 80px;
            background: var(--bg);
        }

        /* Tabs */
        .tabs {
            display: flex; background: #e0e0e0; padding: 4px; border-radius: 8px; margin-bottom: 15px;
        }
        .tab {
            flex: 1; text-align: center; padding: 10px; font-weight: 600; font-size: 0.9rem;
            border-radius: 6px; cursor: pointer; color: #555; transition: 0.2s;
        }
        .tab.active { background: #fff; color: var(--primary); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

        /* Inputs */
        .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .input-group label {
            display: block; font-size: 0.8rem; color: #666; margin-bottom: 5px; font-weight: 500;
        }
        .input-group input {
            width: 100%; padding: 10px; font-size: 1rem;
            border: 1px solid #ccc; border-radius: 6px; background: #fff;
            direction: ltr; text-align: left;
        }
        .input-group input:focus { border-color: var(--primary); outline: none; }

        /* Math Styling */
        .math-step {
            background: #fff; border-right: 4px solid var(--primary);
            padding: 15px; margin-bottom: 15px; border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            font-size: 0.95rem;
        }
        .math-step h4 { margin: 0 0 10px 0; color: var(--primary); font-size: 1rem; }
        .math-content { direction: ltr; text-align: left; overflow-x: auto; }
        .desc { font-size: 0.85rem; color: #555; margin-bottom: 5px; }

        .section { display: none; }
        .section.active { display: block; }
    </style>
</head>
<body>

<div id="canvas-container">
    <div class="overlay-hint">זום וגרירה נתמכים</div>
    <canvas id="simCanvas"></canvas>
</div>

<div class="control-strip">
    <div class="slider-header">
        <span>מצב בוכנה</span>
        <span id="angleDisplay" style="color:#444">0°</span>
    </div>
    <input type="range" id="liftSlider" min="0" max="100" value="25">
</div>

<div class="scroll-content">
    <div class="tabs">
        <div class="tab active" onclick="switchTab('inputs', event)">נתונים</div>
        <div class="tab" onclick="switchTab('calcs', event)">חישובים מפורטים</div>
    </div>

    <div id="tab-inputs" class="section active">
        <div class="input-grid">
            <div class="input-group"><label>A: אורך קורה עליונה (cm)</label><input type="number" id="inp_A" value="400"></div>
            <div class="input-group"><label>B: אורך בסיס (cm)</label><input type="number" id="inp_B" value="350"></div>
            <div class="input-group"><label>C: זרוע הרמה (cm)</label><input type="number" id="inp_C" value="180"></div>
            <div class="input-group"><label>D: זרוע תומכת (cm)</label><input type="number" id="inp_D" value="150"></div>
            <div class="input-group"><label>E: מיקום בוכנה על C (cm)</label><input type="number" id="inp_E" value="100"></div>
            <div class="input-group"><label>H: מיקום בסיס בוכנה (cm)</label><input type="number" id="inp_H" value="120"></div>
            <div class="input-group"><label>W: עומס/משקל (kg)</label><input type="number" id="inp_Load" value="6000"></div>
            <div class="input-group"><label>Ø: קוטר בוכנה (cm)</label><input type="number" id="inp_PistonD" value="10"></div>
        </div>
        <p style="font-size:0.8rem; color:#888; margin-top:10px;">* המידות מעודכנות בזמן אמת בסימולציה</p>
    </div>

    <div id="tab-calcs" class="section">
        <div id="math-display"></div>
    </div>
</div>

<script>
// --- CORE LOGIC ---
let params = { A:400, B:350, C:180, D:150, E:100, H:120, Load:6000, PistonD: 10 };

// Points & Vectors
let P1={x:0,y:0}, P2={x:0,y:0}, P3={x:0,y:0}, P4={x:0,y:0};
let P_piston_base={x:0,y:0}, P_piston_head={x:0,y:0};

// View
let cam = { x: 0, y: 0, scale: 1.0 };
let isDragging = false;
let lastTouch = { x:0, y:0, dist:0 };

function solveGeometry(sliderVal) {
    // 1. Calculate Angle C based on slider (45 to 135 degrees)
    const angleC_deg = 45 + (sliderVal/100)*(135-45);
    const radC = angleC_deg * Math.PI / 180;

    // 2. Set Fixed Points
    P1 = {x: 0, y: 0};
    P4 = {x: params.B, y: 0};
    P_piston_base = {x: params.H, y: 0};

    // 3. Calculate P2 (Tip of Arm C)
    P2.x = params.C * Math.cos(radC);
    P2.y = params.C * Math.sin(radC);

    // 4. Calculate P3 (Tip of Arm D) using Circle Intersection
    const d_base = Math.hypot(P4.x - P2.x, P4.y - P2.y);
    if (d_base > params.A + params.D || d_base < Math.abs(params.A - params.D)) return null;

    const a = (params.A**2 - params.D**2 + d_base**2) / (2 * d_base);
    const h = Math.sqrt(Math.max(0, params.A**2 - a*a));
    const x2 = P2.x + a * (P4.x - P2.x) / d_base;
    const y2 = P2.y + a * (P4.y - P2.y) / d_base;

    // Elbow up solution
    P3.x = x2 - h * (P4.y - P2.y) / d_base;
    P3.y = y2 + h * (P4.x - P2.x) / d_base;

    // 5. Piston Head
    const ratio = params.E / params.C;
    P_piston_head.x = P2.x * ratio;
    P_piston_head.y = P2.y * ratio;

    // 6. Angles for output
    const angD_rad = Math.atan2(P3.y - P4.y, P3.x - P4.x);
    const angBD = 180 - (angD_rad * 180 / Math.PI); // Internal angle
    const angPiston = Math.atan2(P_piston_head.y - P_piston_base.y, P_piston_head.x - P_piston_base.x);

    return { radC, angD: angD_rad, angBD, angPiston };
}

function solveForces(geo) {
    if(!geo) return null;
    const W = params.Load;

    // --- STEP 1: BEAM A EQUILIBRIUM ---
    // We sum moments about P2 to find Force in D.
    // Load acts in middle of A.
    const midA = { x: (P2.x+P3.x)/2, y: (P2.y+P3.y)/2 };
    
    // Moment Arm for Load (Horizontal distance from P2)
    const arm_load = midA.x - P2.x;
    const M_Load = arm_load * W; // kg*cm

    // Moment Arm for Force D (Perpendicular distance from P2 to line P3-P4)
    // Vector P2->P3
    const r_D = { x: P3.x - P2.x, y: P3.y - P2.y };
    // Unit Vector of Force D
    const u_D = { x: Math.cos(geo.angD), y: Math.sin(geo.angD) };
    // Cross Product (2D) for perpendicular distance
    const arm_D = r_D.x * u_D.y - r_D.y * u_D.x;

    let F_d = 0;
    if(Math.abs(arm_D) > 0.01) F_d = M_Load / arm_D;

    // --- STEP 2: REACTION ON ARM C ---
    // Force A exerts on C.
    // F_A_on_C = Load + Force_D (Vector addition)
    // Vertical: -W + Fd*sin(D)
    // Horizontal: Fd*cos(D)
    const F_A_on_C_x = F_d * Math.cos(geo.angD);
    const F_A_on_C_y = F_d * Math.sin(geo.angD) - W; 

    // --- STEP 3: ARM C EQUILIBRIUM ---
    // Sum moments about P1 (0,0).
    // Moment from A force: Cross product r x F
    // r is P2. F is F_A_on_C.
    // M = x*Fy - y*Fx
    const M_Reaction = P2.x * F_A_on_C_y - P2.y * F_A_on_C_x;

    // Piston Moment Arm
    // Vector P1->PistonHead is just P_piston_head
    // Force direction is PistonBase -> PistonHead (or vice versa)
    const u_P = { x: Math.cos(geo.angPiston), y: Math.sin(geo.angPiston) };
    // Lever arm = Cross product of position and force direction
    const arm_Piston = P_piston_head.x * u_P.y - P_piston_head.y * u_P.x;

    let F_p = 0;
    if(Math.abs(arm_Piston) > 0.01) F_p = -M_Reaction / arm_Piston;

    // Pressure
    const area = Math.PI * Math.pow(params.PistonD/2, 2);
    const pressure = Math.abs(F_p) / area;

    return {
        arm_load, M_Load,
        arm_D, F_d,
        M_Reaction: Math.abs(M_Reaction),
        arm_Piston: Math.abs(arm_Piston),
        F_p: Math.abs(F_p),
        area, pressure
    };
}

// --- RENDERING ---
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');

function initCanvas() {
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    // Auto fit
    cam.scale = Math.min(w/(params.B*1.3), h/(params.A+params.C));
    cam.x = w/2 - (params.B*cam.scale)/2;
    cam.y = h - 60;
}

function draw(geo) {
    const w = canvas.width; const h = canvas.height;
    ctx.clearRect(0,0,w,h);
    
    if(!geo) {
        ctx.fillStyle = "red"; ctx.font="16px sans-serif"; ctx.fillText("שגיאה בגיאומטריה", 50, 50);
        return;
    }

    ctx.save();
    ctx.translate(cam.x, cam.y);
    ctx.scale(cam.scale, -cam.scale);

    const line = (p1, p2, c, w) => { ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.strokeStyle=c; ctx.lineWidth=w; ctx.lineCap='round'; ctx.stroke(); };
    const midpoint = (p1, p2) => ({x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2});
    
    // Helper for Text Labels (unflip)
    const label = (txt, p, ox, oy, col='#222') => {
        ctx.save(); ctx.translate(p.x, p.y); ctx.scale(1, -1);
        ctx.font = "bold 16px Arial"; ctx.fillStyle = col; ctx.textAlign = 'center';
        ctx.fillText(txt, ox, -oy);
        ctx.restore();
    };

    // Floor
    line({x:-100,y:-10}, {x:params.B+100,y:-10}, '#ccc', 2);

    // Members
    line(P1, P4, '#444', 6); label("B", midpoint(P1,P4), 0, -20);
    line(P1, P2, '#666', 8); label("C", midpoint(P1,P2), -20, 0);
    line(P4, P3, '#666', 8); label("D", midpoint(P4,P3), 20, 0);
    line(P2, P3, '#0288D1', 10); label("A", midpoint(P2,P3), 0, 25, '#0288D1');

    // Piston
    ctx.lineWidth = 12; ctx.strokeStyle = '#E65100'; ctx.beginPath();
    ctx.moveTo(P_piston_base.x, P_piston_base.y);
    const pm = midpoint(P_piston_base, P_piston_head);
    ctx.lineTo(pm.x, pm.y); ctx.stroke();
    ctx.lineWidth = 5; ctx.strokeStyle = '#888'; ctx.beginPath();
    ctx.moveTo(pm.x, pm.y); ctx.lineTo(P_piston_head.x, P_piston_head.y); ctx.stroke();
    label("Piston", pm, 0, 20, '#E65100');

    // Load Arrows
    const arrCol = '#D32F2F';
    const arrLen = 40 / cam.scale;
    const head = 10 / cam.scale;
    for(let i=1; i<=3; i++) {
        const t = i/4;
        const ax = P2.x + t*(P3.x - P2.x);
        const ay = P2.y + t*(P3.y - P2.y);
        ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(ax, ay-arrLen);
        ctx.strokeStyle = arrCol; ctx.lineWidth = 2; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ax, ay-arrLen-head); 
        ctx.lineTo(ax-head/2, ay-arrLen); ctx.lineTo(ax+head/2, ay-arrLen);
        ctx.fillStyle = arrCol; ctx.fill();
    }
    
    // Angle B-D visual
    ctx.beginPath(); ctx.arc(P4.x, P4.y, 30, geo.angD, Math.PI);
    ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth=1; ctx.stroke();
    label(geo.angBD.toFixed(0)+"°", P4, -40, 10, '#d32f2f');

    // Joints
    [P1, P2, P3, P4, P_piston_base, P_piston_head].forEach(p => {
        ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
        ctx.fillStyle='#fff'; ctx.fill(); ctx.stroke();
    });

    ctx.restore();
}

// --- MATH UPDATE ---
function updateMath(geo, res) {
    document.getElementById('angleDisplay').innerText = geo.angBD.toFixed(0) + "°";

    const f = n => n.toLocaleString('en-US', {maximumFractionDigits:1});
    const el = document.getElementById('math-display');

    const html = `
    <div class="math-step">
        <h4>1. שיווי משקל בקורה העליונה (Beam A)</h4>
        <div class="desc">מחשבים את הכוח שזרוע D צריכה להפעיל כדי להחזיק את העומס.</div>
        <div class="math-content">
            $$ M_{load} = W \\cdot d_x = ${params.Load} \\cdot ${f(res.arm_load)} = ${f(res.M_Load)} \\text{ kg cm} $$
            <br>
            <div class="desc">חישוב זרוע המומנט האפקטיבית (ניצבת) של זרוע D:</div>
            $$ d_{\\perp D} = \\text{CrossProduct}(r_D, u_D) = ${f(res.arm_D)} \\text{ cm} $$
            <br>
            <div class="desc">סכום מומנטים שווה לאפס:</div>
            $$ F_D = \\frac{M_{load}}{d_{\\perp D}} = \\frac{${f(res.M_Load)}}{${f(res.arm_D)}} $$
            $$ \\mathbf{F_D = ${f(res.F_d)} \\text{ kg}} $$
        </div>
    </div>

    <div class="math-step">
        <h4>2. שיווי משקל בזרוע הרמה (Arm C)</h4>
        <div class="desc">מחשבים את המומנט שקורה A מפעילה על ציר הסיבוב P1. הבוכנה צריכה להתנגד לזה.</div>
        <div class="math-content">
            $$ M_{reaction} = r_{P2} \\times F_{A \\to C} = ${f(res.M_Reaction)} \\text{ kg cm} $$
            <br>
            <div class="desc">חישוב זרוע הבוכנה (המרחק הניצב מציר P1 לקו הפעולה):</div>
            $$ d_{piston} = ${f(res.arm_Piston)} \\text{ cm} $$
            <br>
            <div class="desc">כוח הבוכנה הנדרש:</div>
            $$ F_{piston} = \\frac{M_{reaction}}{d_{piston}} = \\frac{${f(res.M_Reaction)}}{${f(res.arm_Piston)}} $$
            $$ \\mathbf{F_{piston} = ${f(res.F_p)} \\text{ kg}} $$
        </div>
    </div>

    <div class="math-step">
        <h4>3. לחץ הידראולי</h4>
        <div class="desc">לפי קוטר בוכנה ${params.PistonD} ס"מ</div>
        <div class="math-content">
            $$ Area = \\pi r^2 = \\pi \\cdot ${(params.PistonD/2).toFixed(1)}^2 = ${f(res.area)} \\text{ cm}^2 $$
            $$ P = \\frac{F}{A} = \\frac{${f(res.F_p)}}{${f(res.area)}} $$
            $$ \\mathbf{P = ${f(res.pressure)} \\text{ kg/cm}^2} $$
        </div>
    </div>
    `;

    // Only update DOM if numbers changed significantly to avoid flicker
    if(Math.abs(res.F_p - parseFloat(el.dataset.cache || 0)) > 10) {
        el.dataset.cache = res.F_p;
        el.innerHTML = html;
        MathJax.typesetPromise([el]);
    }
}

// --- EVENTS ---
const cvs = document.getElementById('canvas-container');
cvs.addEventListener('touchstart', e => {
    isDragging=true; 
    if(e.touches.length===2) lastTouch.dist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
    else { lastTouch.x=e.touches[0].clientX; lastTouch.y=e.touches[0].clientY; }
}, {passive:false});

cvs.addEventListener('touchmove', e => {
    e.preventDefault(); if(!isDragging) return;
    if(e.touches.length===2) {
        const d = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
        cam.scale *= (1 + (d-lastTouch.dist)*0.005); lastTouch.dist=d;
    } else {
        cam.x += e.touches[0].clientX-lastTouch.x; cam.y += e.touches[0].clientY-lastTouch.y;
        lastTouch.x=e.touches[0].clientX; lastTouch.y=e.touches[0].clientY;
    }
    requestAnimationFrame(tick);
}, {passive:false});

cvs.addEventListener('touchend', () => isDragging=false);

function tick() {
    ['A','B','C','D','E','H','Load','PistonD'].forEach(k => params[k] = parseFloat(document.getElementById('inp_'+k).value)||0);
    const slider = document.getElementById('liftSlider');
    const geo = solveGeometry(parseFloat(slider.value));
    draw(geo);
    if(geo) updateMath(geo, solveForces(geo));
}

document.querySelectorAll('input').forEach(i => i.addEventListener('input', tick));
document.getElementById('liftSlider').addEventListener('input', tick);

window.switchTab = (t,e) => {
    document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(tb=>tb.classList.remove('active'));
    document.getElementById('tab-'+t).classList.add('active'); e.target.classList.add('active');
};

// Start
initCanvas();
tick();

</script>
</body>
</html>
