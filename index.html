<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Mechanism Lab</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --primary: #2196F3;
            --accent: #FFC107;
            --dark: #333;
            --light: #f5f5f5;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--light);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent body scroll, handle inside containers */
        }

        /* Top Simulation View */
        #canvas-container {
            position: relative;
            width: 100%;
            height: 45vh; /* Top half for visualization */
            background: #eef2f5;
            border-bottom: 2px solid #ddd;
            overflow: hidden;
            touch-action: none; /* Important for custom touch gestures */
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* Zoom Hints */
        .zoom-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.8);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            color: #666;
            pointer-events: none;
        }

        /* Control Strip */
        .control-strip {
            background: #fff;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
            flex-shrink: 0;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            margin-bottom: 5px;
            color: var(--dark);
        }
        input[type=range] {
            width: 100%;
            height: 30px; /* Taller for touch */
        }

        /* Scrollable Data Area */
        .scroll-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 80px; /* Space for bottom scroll */
            background: #fff;
        }

        /* Tabs for Inputs/Results */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            background: #eee;
            border-radius: 8px;
            padding: 4px;
        }
        .tab {
            flex: 1;
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
        }
        .tab.active {
            background: #fff;
            color: var(--primary);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Input Grids */
        .input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .input-group label {
            display: block;
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 5px;
        }
        .input-group input {
            width: 100%;
            padding: 10px;
            font-size: 1rem;
            border: 1px solid #ccc;
            border-radius: 6px;
            background: #f9f9f9;
        }

        /* Calculation Display */
        .math-block {
            background: #fffcf0;
            border: 1px solid #f0e6d2;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }
        .result-highlight {
            color: var(--primary);
            font-weight: bold;
        }

        /* Section visibility */
        .section { display: none; }
        .section.active { display: block; }

    </style>
</head>
<body>

<div id="canvas-container">
    <div class="zoom-hint">pinch to zoom • drag to pan</div>
    <canvas id="simCanvas"></canvas>
</div>

<div class="control-strip">
    <div class="slider-label">
        <span>Lift Piston</span>
        <span id="angleDisplay">0°</span>
    </div>
    <input type="range" id="liftSlider" min="0" max="100" value="20">
</div>

<div class="scroll-content">
    
    <div class="tabs">
        <div class="tab active" onclick="switchTab('inputs')">Inputs</div>
        <div class="tab" onclick="switchTab('calcs')">Calculations</div>
    </div>

    <div id="tab-inputs" class="section active">
        <h3 style="margin-top:0">Dimensions (cm)</h3>
        <div class="input-grid">
            <div class="input-group"><label>A: Top Beam</label><input type="number" id="inp_A" value="400"></div>
            <div class="input-group"><label>B: Chassis Base</label><input type="number" id="inp_B" value="350"></div>
            <div class="input-group"><label>C: Left Arm</label><input type="number" id="inp_C" value="180"></div>
            <div class="input-group"><label>D: Right Arm</label><input type="number" id="inp_D" value="150"></div>
            <div class="input-group"><label>E: Piston Mount (on C)</label><input type="number" id="inp_E" value="100"></div>
            <div class="input-group"><label>H: Piston Base X</label><input type="number" id="inp_H" value="120"></div>
            <div class="input-group"><label>F: Left Support (from P1)</label><input type="number" id="inp_F" value="50"></div>
            <div class="input-group"><label>G: Right Support (from P4)</label><input type="number" id="inp_G" value="50"></div>
        </div>

        <h3>Loads</h3>
        <div class="input-grid">
            <div class="input-group"><label>Load Mass (kg)</label><input type="number" id="inp_Load" value="6000"></div>
        </div>
    </div>

    <div id="tab-calcs" class="section">
        <div class="math-block" id="geo-results">
            </div>

        <div class="math-block" id="math-display">
            </div>
    </div>

</div>

<script>
// --- PHYSICS ENGINE ---
const G_accel = 9.81; 
let params = { A:400, B:350, C:180, D:150, E:100, H:120, F:50, G:50, Load:6000 };

// Calculated Points
let P1={x:0,y:0}, P2={x:0,y:0}, P3={x:0,y:0}, P4={x:0,y:0};
let P_piston_base={x:0,y:0}, P_piston_head={x:0,y:0};
let Sup_L={x:0,y:0}, Sup_R={x:0,y:0}; // Supports

// Camera State
let cam = { x: 0, y: 0, scale: 1.0 };
let isDragging = false;
let lastTouch = { x:0, y:0, dist:0 };

function solveGeometry(sliderVal) {
    // 1. Angle of Link C (Controlled by slider)
    // Map slider 0-100 to 45°-130°
    const angleC_deg = 45 + (sliderVal/100)*(130-45);
    const radC = angleC_deg * Math.PI / 180;

    // 2. Fixed Points
    P1 = {x: 0, y: 0};
    P4 = {x: params.B, y: 0};
    P_piston_base = {x: params.H, y: 0};
    Sup_L = {x: params.F, y: -20}; // Draw slightly below axis
    Sup_R = {x: params.B - params.G, y: -20};

    // 3. Link C Top (P2)
    P2.x = params.C * Math.cos(radC);
    P2.y = params.C * Math.sin(radC);

    // 4. Link D Top (P3) - Intersection of two circles
    const d_base = Math.hypot(P4.x - P2.x, P4.y - P2.y);
    
    // Safety check for impossible geometry
    if (d_base > params.A + params.D || d_base < Math.abs(params.A - params.D) || d_base === 0) return null;

    const a = (params.A**2 - params.D**2 + d_base**2) / (2 * d_base);
    const h = Math.sqrt(Math.max(0, params.A**2 - a*a));
    
    const x2 = P2.x + a * (P4.x - P2.x) / d_base;
    const y2 = P2.y + a * (P4.y - P2.y) / d_base;

    // Elbow up solution
    P3.x = x2 - h * (P4.y - P2.y) / d_base;
    P3.y = y2 + h * (P4.x - P2.x) / d_base;

    // 5. Piston Head
    const ratio = params.E / params.C;
    P_piston_head.x = P2.x * ratio;
    P_piston_head.y = P2.y * ratio;

    // Angles
    const angA = Math.atan2(P3.y - P2.y, P3.x - P2.x);
    const angD = Math.atan2(P3.y - P4.y, P3.x - P4.x);
    const angPiston = Math.atan2(P_piston_head.y - P_piston_base.y, P_piston_head.x - P_piston_base.x);

    return { radC, angA, angD, angPiston };
}

function solveForces(geo) {
    if(!geo) return null;

    // Constants
    const W = params.Load * G_accel; // Newtons
    
    // --- Step 1: Beam A Equilibrium ---
    // Beam A is supported by Link C (at P2) and Link D (at P3).
    // Assume Link D is a two-force member (force acts along line P3-P4).
    // Sum moments about P2 = 0.
    // Force D vector direction:
    const dirD = { x: Math.cos(geo.angD), y: Math.sin(geo.angD) };
    
    // Center of Gravity of Load (Midpoint of A)
    const midA = { x: (P2.x+P3.x)/2, y: (P2.y+P3.y)/2 };
    
    // Vector r_load = midA - P2
    const r_load_x = midA.x - P2.x; // cm
    const r_load_y = midA.y - P2.y; // cm
    // Moment Load = r x F. F is (0, -W). Cross prod 2D: x*Fy - y*Fx
    // M_load = r_load_x * (-W) - r_load_y * 0 = -r_load_x * W
    // Note: We use meters for Moment calc? Let's stay in consistent units. 
    // If distance in cm, force in N, Moment is N-cm.
    const M_load_P2 = r_load_x * (-W);

    // Moment from Link D Force (Fd)
    // Force acts at P3. Vector r_D = P3 - P2.
    // F_vector = Fd * dirD
    const r_D_x = P3.x - P2.x;
    const r_D_y = P3.y - P2.y;
    
    // M_D = (r_D_x * Fd_y) - (r_D_y * Fd_x)
    //     = Fd * (r_D_x * sin(D) - r_D_y * cos(D))
    const lever_D = r_D_x * dirD.y - r_D_y * dirD.x;
    
    let F_d = 0; // Force in Link D (Tension/Compression)
    if(Math.abs(lever_D) > 1e-4) {
        F_d = -M_load_P2 / lever_D; 
    }

    // Reaction on Link C from Beam A (Newton's 3rd Law)
    // Forces on A: W + F_d + F_c = 0
    // F_c_on_A_x = - (0 + F_d * cosD)
    // F_c_on_A_y = - (-W + F_d * sinD)
    // Force A exerts on C is equal and opposite:
    const F_A_on_C_x = F_d * dirD.x;
    const F_A_on_C_y = F_d * dirD.y - W; 

    // --- Step 2: Link C Equilibrium ---
    // Sum moments about P1. Forces: Reaction from A, Piston Force.
    // Moment from A force:
    // r_top = P2 - P1 = P2
    const M_from_A = P2.x * F_A_on_C_y - P2.y * F_A_on_C_x;

    // Piston Force acts at P_piston_head.
    // Direction vector:
    const dirP = { x: Math.cos(geo.angPiston), y: Math.sin(geo.angPiston) };
    const r_pist = P_piston_head; // relative to P1
    
    // M_piston = Fp * (r_pist_x * sinP - r_pist_y * cosP)
    const lever_piston = r_pist.x * dirP.y - r_pist.y * dirP.x;
    
    let F_p = 0;
    if(Math.abs(lever_piston) > 1e-4) {
        F_p = -M_from_A / lever_piston;
    }

    // --- Step 3: Global Reactions at Supports F and G ---
    // Treat whole machine as rigid.
    // Loads: W (at midA). Internal forces cancel out.
    // Supports: R_F (at Sup_L), R_G (at Sup_R).
    // Sum Moments about Sup_L (F):
    // + (R_G_y * dist_FG) - (W * dist_W_F) = 0
    const dist_FG = Sup_R.x - Sup_L.x;
    const dist_W_F = midA.x - Sup_L.x;
    
    let R_G = 0;
    let R_F = 0;
    
    if (dist_FG > 0) {
        R_G = (W * dist_W_F) / dist_FG;
        R_F = W - R_G; // Sum Vertical = 0
    }

    return { F_p, F_d, R_F, R_G, W };
}

// --- RENDERING ---
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');

function initCanvas() {
    // Initial Scale to fit
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w;
    canvas.height = h;
    
    // Center logic
    const mechWidth = params.B;
    const mechHeight = params.C;
    cam.scale = Math.min(w/(mechWidth*1.5), h/(mechHeight*1.5));
    cam.x = (w - mechWidth*cam.scale)/2;
    cam.y = h - 50; // Bottom aligned
}

function draw(geo) {
    if(!geo) return;
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0, 0, w, h);
    
    ctx.save();
    ctx.translate(cam.x, cam.y);
    ctx.scale(cam.scale, -cam.scale); // Flip Y

    // Helper: Line
    const line = (p1, p2, c, lw) => {
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = c; ctx.lineWidth = lw; ctx.lineCap='round'; ctx.stroke();
    };

    // Helper: Support Triangle
    const drawSupport = (p, label) => {
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.moveTo(p.x, 0);
        ctx.lineTo(p.x - 10, -20);
        ctx.lineTo(p.x + 10, -20);
        ctx.closePath();
        ctx.fill();
        
        ctx.save();
        ctx.scale(1, -1);
        ctx.fillStyle = '#000';
        ctx.font = '14px sans-serif';
        ctx.fillText(label, p.x - 5, 40);
        ctx.restore();
    };

    // Floor
    line({x:-100, y:-20}, {x: params.B+100, y:-20}, '#ddd', 2);

    // Chassis Line
    line(P1, P4, '#333', 4);

    // Supports
    drawSupport(Sup_L, "F");
    drawSupport(Sup_R, "G");

    // Piston
    // Cylinder
    ctx.lineWidth = 14; ctx.strokeStyle = '#FFC107';
    ctx.beginPath(); ctx.moveTo(P_piston_base.x, P_piston_base.y);
    const midP = {x: (P_piston_base.x+P_piston_head.x)/2, y: (P_piston_base.y+P_piston_head.y)/2};
    ctx.lineTo(midP.x, midP.y); ctx.stroke();
    // Rod
    ctx.lineWidth = 6; ctx.strokeStyle = '#999';
    ctx.beginPath(); ctx.moveTo(midP.x, midP.y); ctx.lineTo(P_piston_head.x, P_piston_head.y); ctx.stroke();

    // Arms
    line(P1, P2, '#444', 8); // C
    line(P4, P3, '#444', 8); // D
    line(P2, P3, '#F44336', 10); // A (Load)

    // Joints
    [P1, P2, P3, P4, P_piston_base, P_piston_head].forEach(p => {
        ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
        ctx.fillStyle='#fff'; ctx.fill(); ctx.stroke();
    });

    // Angle Arc for C
    ctx.beginPath();
    ctx.arc(P1.x, P1.y, 30, 0, geo.radC);
    ctx.strokeStyle = 'rgba(33, 150, 243, 0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.restore();
}

// --- GESTURES (Pan/Zoom) ---
canvas.addEventListener('touchstart', e => {
    isDragging = true;
    if(e.touches.length === 2) {
        lastTouch.dist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
        );
    } else {
        lastTouch.x = e.touches[0].clientX;
        lastTouch.y = e.touches[0].clientY;
    }
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault(); // Stop scrolling while using canvas
    if(!isDragging) return;

    if(e.touches.length === 2) {
        // Pinch Zoom
        const dist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
        );
        const delta = dist - lastTouch.dist;
        cam.scale *= (1 + delta * 0.005);
        lastTouch.dist = dist;
        requestAnimationFrame(updateLoop);
    } else {
        // Pan
        const dx = e.touches[0].clientX - lastTouch.x;
        const dy = e.touches[0].clientY - lastTouch.y;
        cam.x += dx;
        cam.y += dy;
        lastTouch.x = e.touches[0].clientX;
        lastTouch.y = e.touches[0].clientY;
        requestAnimationFrame(updateLoop);
    }
}, {passive: false});

canvas.addEventListener('touchend', () => isDragging = false);


// --- MAIN LOGIC ---
function updateLoop() {
    // Read Slider
    const slideVal = parseFloat(document.getElementById('liftSlider').value);
    
    // Solve
    const geo = solveGeometry(slideVal);
    
    if(geo) {
        const forces = solveForces(geo);
        draw(geo);
        updateData(geo, forces);
    }
}

function updateData(geo, forces) {
    // 1. Angle Display on Slider
    document.getElementById('angleDisplay').innerText = (geo.radC * 180/Math.PI).toFixed(0) + "°";

    // 2. Geometry Block
    const toDeg = r => (r*180/Math.PI).toFixed(1);
    document.getElementById('geo-results').innerHTML = `
        <strong>Geometry Data:</strong><br>
        Angle Arm C: <span class="result-highlight">${toDeg(geo.radC)}°</span><br>
        Angle Beam A: <span class="result-highlight">${toDeg(geo.angA)}°</span><br>
        Angle Arm D: <span class="result-highlight">${toDeg(geo.angD)}°</span><br>
        Piston Angle: <span class="result-highlight">${toDeg(geo.angPiston)}°</span>
    `;

    // 3. Math Block (LaTeX)
    const angP_deg = toDeg(geo.angPiston);
    const Fp_kN = (forces.F_p / 1000).toFixed(2);
    const W_kN = (forces.W / 1000).toFixed(2);
    const RF_kN = (forces.R_F / 1000).toFixed(2);
    const RG_kN = (forces.R_G / 1000).toFixed(2);

    const tex = `
    $$ \\text{Load } W = ${W_kN} \\text{ kN} $$
    $$ \\textbf{1. Piston Force Calculation} $$
    $$ F_{piston} = \\frac{M_{load}}{d_{\\perp}} $$
    $$ \\theta_{piston} = ${angP_deg}^\\circ $$
    $$ \\cos(\\theta_p) = ${Math.cos(geo.angPiston).toFixed(3)}, \\sin(\\theta_p) = ${Math.sin(geo.angPiston).toFixed(3)} $$
    $$ \\mathbf{F_{piston} = ${Fp_kN} \\text{ kN}} $$
    
    $$ \\textbf{2. Ground Reactions (Supports)} $$
    $$ \\sum M_F = 0 \\implies R_G = \\frac{W \\cdot d_{w}}{d_{FG}} $$
    $$ R_G = ${RG_kN} \\text{ kN}, \\quad R_F = ${RF_kN} \\text{ kN} $$
    `;

    const el = document.getElementById('math-display');
    // Simple diff check to avoid flickering mathjax too often
    if(Math.abs(forces.F_p - (el.dataset.lastFp || 0)) > 100) {
        el.dataset.lastFp = forces.F_p;
        el.innerHTML = tex;
        if(window.MathJax) MathJax.typesetPromise([el]);
    }
}

// Input Listeners
document.querySelectorAll('input').forEach(i => i.addEventListener('input', updateLoop));

// UI Switching
window.switchTab = function(tabName) {
    document.querySelectorAll('.section').forEach(d => d.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.getElementById('tab-'+tabName).classList.add('active');
    // Highlight clicked tab
    event.target.classList.add('active');
}

// Start
initCanvas();
updateLoop();

</script>
</body>
</html>
